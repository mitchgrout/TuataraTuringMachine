<html>
<h2> Overview of Tuatara Turing Machine Simulator </h2>
<p>
This program is a graphical toolkit for designing and simulating various types of deterministic
finite-state machines.  It was written by Jimmy Foulds during 2006-2007, and later updated and
extended by Mitchell Grout during 2017-2018, with funding from the Department of Mathematics at the
University of Waikato, New Zealand.
</p>

<p>
Finite-state machines are a mathematical model of computation, with applications ranging from string
matching to simulating algorithms.  All finite-state machines consist of at least 5 components: A
finite alphabet of symbols recognized by the machine, a set of states, a start state, a set of final
states, and a transition function which maps a state and symbol to another state.  Machines may be
either deterministic, or nondeterministic.  Below is a description of all machines currently
supported by Tuatara Turing Machine Simulator.
</p>

<p>
<h3> Turing Machines </h3>
A Turing machine is a class of abstract machine which is considered to be capable of performing any
computation that is specifiable by an algorithm.  
</p>

<p>
Formally, we define a Turing machine to be
<i>M</i> = (<i>Q</i>, <i>&delta;</i>, <i>q<sub>0</sub></i>, <i>q<sub>f</sub></i>),
with finite tape alphabet <i>Y</i> and input alphabet <i>X</i> &sub; <i>Y</i>, consisting of:
<ul>
    <li> A finite set <i>Q</i> of states.
    <li> A partial function <i>&delta;</i> : <i>Q &times; Y &rarr; Q &times; </i>(<i>Y</i> &cup; {L,R}),
         the transition function.
    <li> A start state <i>q<sub>0</sub></i> &isin; <i>Q</i>.
    <li> A halt state <i>q<sub>f</sub></i> &isin; <i>Q</i>.
    <li> <i>&delta;</i>(<i>q<sub>f</sub></i>, <i>y</i>) is undefined for all
         <i>y</i> &isin; <i>Y</i>.
    <li> There is a symbol <i>b</i> &isin; <i>Y</i> with <i>b</i> &notin; <i>X</i>, called "blank".
</ul>
</p>

<p>
A Turing machine comes equipped with an infinitely large tape, in which individual cells can be read
and overwritten.  The tape extends infinitely to the right.  Additionally, we have a read/write head
which is initially over the left-most cell of the tape, and is capable of reading a symbol from the
tape, writing a symbol, and moving along the tape.
</p>

<p>
<h3> Deterministic Finite-State Automata (DFSA) </h3>
A DFSA is a class of abstract machine which is capable of determining if a string belongs to some
regular language.  We denote the language accepted by a DFSA <i>M</i> to be <i>L(M)</i>.
</p>

<p>
Formally, we define a DFSA to be 
<i>M</i> = (<i>Q</i>, <i>&delta;</i>, <i>q<sub>0</sub></i>, <i>F</i>)</i>, 
with finite alphabet <i>&Sigma;</i>, consisting of:
<ul>
    <li> A finite set <i>Q</i> of states.
    <li> A total function <i>&delta; : Q &times; &Sigma; &rarr; Q</i>, the transition function.
    <li> A start state <i>q<sub>0</sub></i> &isin; <i>Q</i>.
    <li> A set of accepting states, <i>F</i> &sube; <i>Q</i>.
</ul>
</p>

<p>
A DFSA takes as input some string <i>u</i> &isin; <i>&Sigma;*</i>, reading each symbol from
left-to-right, and determines if <i>u</i> &isin; <i>L</i>(<i>M</i>) &sube; <i>&Sigma;*</i>.
</p>
</html>
